@page "/downloadrelations"
@using Google.Protobuf.WellKnownTypes
@using Grpc.Net.Client
@using System.Text.Json
@using System.Text.Json.Serialization
@using static SCHQ_Protos.SCHQ_Relations
@attribute [StreamRendering(false)]
@inject IJSRuntime JsRuntime
@inject IConfiguration Config
@inject NavigationManager Navigation

<script>
  window.downloadFileFromStream = async (fileName, contentStreamReference) => {
    const arrayBuffer = await contentStreamReference.arrayBuffer();
    const blob = new Blob([arrayBuffer]);
    const url = URL.createObjectURL(blob);
    const anchorElement = document.createElement('a');
    anchorElement.href = url;
    anchorElement.download = fileName ?? '';
    anchorElement.click();
    anchorElement.remove();
    URL.revokeObjectURL(url);
  }
</script>

<PageTitle>SCHQ Web</PageTitle>

<h1>Download Relations</h1>

@if (string.IsNullOrWhiteSpace(Channel)) {
  <p>No channel name provided</p>
} else {
  <p>Download relations for channel <b>@Channel</b></p>
  <p>
    <div class="form-floating">
      <input type="password" class="form-control" id="floatingInputGroupChannelPassword" placeholder="Channel Password" @bind-value=Password disabled="@Downloading">
      <label for="floatingInputGroupChannelPassword">Channel Password</label disabled="@(!Downloading)">
    </div>
  </p>
  <p>
    <button type="button" class="btn btn-outline-primary" @onclick="Back" disabled="@Downloading">Back</button>
    <button type="button" class="btn btn-primary" @onclick="Download" disabled="@Downloading">
      <svg class="bi" width="16" height="16" fill="currentColor">
        <use xlink:href="/lib/bootstrap-icons/bootstrap-icons.svg#download" />
      </svg>
      Download
    </button>
  </p>
}

@code {
  [SupplyParameterFromQuery]
  public string? Channel { get; set; }
  private string? Password;
  private bool Downloading { get; set; }

  private async Task Download() {
    Downloading = true;
    string? gRPC_Url = Config.GetValue<string>("gRPC_Url");
    if (gRPC_Url != null) {
      SCHQ_RelationsClient gRPC_Client = new(GrpcChannel.ForAddress(gRPC_Url, new() {
        HttpHandler = new SocketsHttpHandler() {
          PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
          KeepAlivePingDelay = TimeSpan.FromSeconds(60),
          KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
          EnableMultipleHttp2Connections = true
        }
      }));
      RelationsReply reply = await gRPC_Client.GetRelationsAsync(new() {
        Channel = Channel,
        Password = Password ?? string.Empty
      });
      if (reply?.Relations != null) {
        try {
          using MemoryStream relationsStream = new();
          JsonSerializer.Serialize<RelationInfo[]>(relationsStream, reply.Relations.ToArray() ?? [],
            new JsonSerializerOptions() {
              DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingDefault,
              WriteIndented = true
            });
            using var streamRef = new DotNetStreamReference(relationsStream);
            streamRef.Stream.Position = 0;
            await JsRuntime.InvokeVoidAsync("downloadFileFromStream", $"SCHQ_Web_Relations_{Channel}_{DateTime.Now:yyyyMMdd_HHmmss}.json", streamRef);
        } catch {}
      }
    }
    Downloading = false;
  }

  private void Back() {
    Navigation.NavigateTo("/");
  }
}
