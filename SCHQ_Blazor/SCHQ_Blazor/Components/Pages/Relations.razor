@page "/relations"
@using Google.Protobuf.WellKnownTypes
@using Grpc.Core
@using Grpc.Net.Client
@using static SCHQ_Protos.SCHQ_Relations
@attribute [StreamRendering(false)]
@inject IConfiguration Config

<PageTitle>SCHQ Web</PageTitle>

<h1>Relations</h1>

@if (relations == null) {
  <p><em>Loading...</em></p>
} else if (relations.Length == 0) {
  <p><em>No relations found</em></p>
  <p><b>Channel Password:</b><br /><input class="form-control" type="password" placeholder="Password" @bind-value=ChannelPassword /></p>
  <p>
    <div>
      <button class="btn btn-primary" type="button" @onclick="GetRelations" disabled="@SyncActive">Reload Relations</button>
      <button class="@SyncButtonClass" type="button" @onclick="SyncRelations">
        <span class="spinner-border spinner-border-sm" aria-hidden="true" hidden="@(!SyncActive)" />
        <span role="status">@SyncButtonText</span>
      </button>
    </div>
  </p>
} else {
  <p>A list of all relations for channel <b>@Channel</b></p>
  <p>
    <input class="form-control" type="text" placeholder="Filter..." @bind="Filter" @bind:event="oninput" />
    <div>
      <input type="checkbox" checked="@FilterFriendly" @onchange="@((args) => FilterFriendly = (bool?)args.Value)" /> Friendly
      <input type="checkbox" checked="@FilterNeutral" @onchange="@((args) => FilterNeutral = (bool?)args.Value)" /> Neutral
      <input type="checkbox" checked="@FilterBogey" @onchange="@((args) => FilterBogey = (bool?)args.Value)" /> Bogey
      <input type="checkbox" checked="@FilterBandit" @onchange="@((args) => FilterBandit = (bool?)args.Value)" /> Bandit
    </div>
    <div>
      <input type="checkbox" checked="@FilterNotAssigned" @onchange="@((args) => FilterNotAssigned = (bool?)args.Value)" /> Not assigned
      <input type="checkbox" checked="@FilterOrganization" @onchange="@((args) => FilterOrganization = (bool?)args.Value)" /> Organization
    </div>
  </p>
  <p><b>Channel Password:</b><br /><input class="form-control" type="password" placeholder="Password" @bind-value=ChannelPassword /></p>
  <p>
    <div>
      <button class="btn btn-primary" type="button" @onclick="GetRelations" disabled="@SyncActive">Reload Relations</button>
      <button class="@SyncButtonClass" type="button" @onclick="SyncRelations">
        <span class="spinner-border spinner-border-sm" aria-hidden="true" hidden="@(!SyncActive)" />
        <span role="status">@SyncButtonText</span>
      </button>
    </div>
  </p>
  <table class="table table-striped">
    <thead>
      <tr>
        <th scope="col" width="1%">Type</th>
        <th scope="col">Name</th>
        <th scope="col" width="1%">Action</th>
      </tr>
    </thead>
    <tbody>
      @foreach (var relation in relations.Where(r => IsVisible(r))) {
        <tr>
          <td class="@GetRelationClass(relation)">@(relation.Type == RelationType.Handle ? "👤" : "🌐")</td>
          <td>@relation.Name</td>
          <td>
            <div class="btn-group" role="group">
              <button type="button" disabled="@(relation.Relation == RelationValue.Friendly)" class="btn btn-success btn-sm text-white" @onclick="() => SetRelation(relation, RelationValue.Friendly)">FR</button>
              <button type="button" disabled="@(relation.Relation == RelationValue.Neutral)" class="btn btn-secondary btn-sm text-white" @onclick="() => SetRelation(relation, RelationValue.Neutral)">NE</button>
              <button type="button" disabled="@(relation.Relation == RelationValue.Bogey)" class="btn btn-warning btn-sm text-dark" @onclick="() => SetRelation(relation, RelationValue.Bogey)">BO</button>
              <button type="button" disabled="@(relation.Relation == RelationValue.Bandit)" class="btn btn-danger btn-sm text-white" @onclick="() => SetRelation(relation, RelationValue.Bandit)">BA</button>
              <button type="button" disabled="@(relation.Relation == RelationValue.NotAssigned)" class="btn btn-dark btn-sm text-white" @onclick="() => SetRelation(relation, RelationValue.NotAssigned)">NA</button>
            </div>
          </td>
        </tr>
      }
    </tbody>
  </table>
}

@code {
  [SupplyParameterFromQuery]
  public string? Channel { get; set; }
  private string? ChannelPassword { get; set; }
  public string? Filter { get; set; }
  public bool? FilterNotAssigned { get; set; }
  public bool? FilterFriendly { get; set; } = true;
  public bool? FilterNeutral { get; set; } = true;
  public bool? FilterBogey { get; set; } = true;
  public bool? FilterBandit { get; set; } = true;
  public bool? FilterOrganization { get; set; } = true;
  public bool SyncActive { get; set; } = false;
  public string SyncButtonText {
    get {
      return SyncActive ? "Stop Sync" : "Start Sync";
    }
  }
  public string SyncButtonClass {
    get {
      return SyncActive ? "btn btn-danger" : "btn btn-primary";
    }
  }

  private RelationInfo[]? relations;
  private CancellationTokenSource? CTS;

  protected async override Task OnInitializedAsync() {
    await GetRelations();
  }

  private async Task GetRelations() {
    string? gRPC_Url = Config.GetValue<string>("gRPC_Url");
    if (gRPC_Url != null && !string.IsNullOrWhiteSpace(Channel)) {
      SCHQ_RelationsClient gRPC_Client = new(GrpcChannel.ForAddress(gRPC_Url, new() {
          HttpHandler = new SocketsHttpHandler() {
            PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
            KeepAlivePingDelay = TimeSpan.FromSeconds(60),
            KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
            EnableMultipleHttp2Connections = true
          }
        }));
      RelationsReply reply = await gRPC_Client.GetRelationsAsync(new() { Channel = Channel, Password = ChannelPassword ?? string.Empty });
      relations = [.. reply?.Relations];
    }
  }

  private async void SetRelation(RelationInfo relation, RelationValue value) {
    string? gRPC_Url = Config.GetValue<string>("gRPC_Url");
    if (gRPC_Url != null) {
      SCHQ_RelationsClient gRPC_Client = new(GrpcChannel.ForAddress(gRPC_Url, new() {
        HttpHandler = new SocketsHttpHandler() {
          PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
          KeepAlivePingDelay = TimeSpan.FromSeconds(60),
          KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
          EnableMultipleHttp2Connections = true
        }
      }));
      SuccessReply reply = await gRPC_Client.SetRelationAsync(new() {
        Channel = Channel,
        Relation = new() {
          Type = relation.Type,
          Name = relation.Name,
          Relation = value
        }
      });
      if (reply.Success && relations != null) {
        relations.First(r => r.Type == relation.Type && r.Name == relation.Name).Relation = value;
        StateHasChanged();
      }

    }
  }

  private async void SyncRelations() {
    string? gRPC_Url = Config.GetValue<string>("gRPC_Url");
    if (gRPC_Url != null) {
      try {
        if (SyncActive) {
          if (CTS != null && !CTS.IsCancellationRequested) {
            CTS.Cancel(true);
          }
          SyncActive = false;
        } else {
          SyncActive = true;
          CTS = new();
          await GetRelations();
          StateHasChanged();
          SCHQ_RelationsClient gRPC_Client = new(GrpcChannel.ForAddress(gRPC_Url, new() {
              HttpHandler = new SocketsHttpHandler() {
                PooledConnectionIdleTimeout = Timeout.InfiniteTimeSpan,
                KeepAlivePingDelay = TimeSpan.FromSeconds(60),
                KeepAlivePingTimeout = TimeSpan.FromSeconds(30),
                EnableMultipleHttp2Connections = true
              }
            }));
          using var streamingCall = gRPC_Client.SyncRelations(new() { Channel = Channel, Password = ChannelPassword ?? string.Empty }, cancellationToken: CTS.Token);
          try {
            await foreach (SyncRelationsReply rel in streamingCall.ResponseStream.ReadAllAsync(cancellationToken: CTS.Token)) {
              if (relations?.Any(r => r.Type == rel.Relation.Type && r.Name == rel.Relation.Name) ?? false) {
                relations.First(r => r.Type == rel.Relation.Type && r.Name == rel.Relation.Name).Relation = rel.Relation.Relation;
              } else {
                relations = [.. relations?.Concat([rel.Relation]).OrderByDescending(r => r.Type).ThenBy(r => r.Name)];
              }
              StateHasChanged();
            }
          } catch { }
          SyncActive = false;
          StateHasChanged();
        }
      } catch { }
    }
  }

  public bool IsVisible(RelationInfo relation)
  {
    return (string.IsNullOrWhiteSpace(Filter) || relation.Name.Contains(Filter, StringComparison.InvariantCultureIgnoreCase)) &&
    (relation.Relation switch {
      RelationValue.NotAssigned => FilterNotAssigned,
      RelationValue.Friendly => FilterFriendly,
      RelationValue.Neutral => FilterNeutral,
      RelationValue.Bogey => FilterBogey,
      RelationValue.Bandit => FilterBandit,
      _ => false
    } ?? false) &&
    (relation.Type == RelationType.Handle || (FilterOrganization.HasValue && FilterOrganization.Value));
  }

  public string GetRelationClass(RelationInfo relation) {
    return relation.Relation switch {
      RelationValue.NotAssigned => "p-3 mb-2 bg-dark text-white",
      RelationValue.Friendly => "p-3 mb-2 bg-success text-white",
      RelationValue.Neutral => "p-3 mb-2 bg-secondary text-white",
      RelationValue.Bogey => "p-3 mb-2 bg-warning text-dark",
      RelationValue.Bandit => "p-3 mb-2 bg-danger text-white",
      _ => "p-3 mb-2 bg-transparent text-dark"
    };
  }
}
